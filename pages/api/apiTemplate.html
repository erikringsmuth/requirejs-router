<div class="row">
  <div class="col-xs-12">
    <h2>Router API</h2>

    <ul>
      <li><code>router.routes</code> - All registered routes</li>
      <li><code>router.registerRoutes(routes)</code> - Register your routes</li>
      <li><code>router.init([options])</code> - Set up event handlers and trigger the initial page load</li>
      <li><code>router.on('routeload', routeLoadedCallback)</code> - Called when the route's AMD module finishes loading</li>
      <li><code>router.routeArguments([route, [url]])</code> - Returns an object with the path variables and query parameter values from the URL</li>
      <li><code>router.urlPath(url)</code> - Returns the hash path if it exists otherwise returns the normal path</li>
      <li><code>router.activeRoute</code> - A reference to the active route {path: '/home', moduleId: 'home/homeView'}</li>
      <li><code>router.loadCurrentRoute()</code> - Manually tell the router to load the module for the current route</li>
      <li><code>router.testRoute(route, [url])</code> - Test if the route matches the current URL</li>
      <li><code>router.on('statechange', onStateChangeCallback)</code> - Called when a hashchange or popstate event is fired</li>
      <li><code>router.fire(eventName, [arg1, [arg2]])</code> - Manually fire an event</li>
      <li><code>router.off(eventName, eventHandler)</code> - Remove an event handler</li>
    </ul>

    <h2>routes</h2>

    <p>A route has 3 properties</p>
    <ul>
      <li><code>path</code> (string or regex) - The URL path</li>
      <li><code>moduleId</code> (string) - The AMD module ID</li>
      <li><code>active</code> (boolean) - indicates if it's the active route</li>
    </ul>
    <p>A simple route object would look like this <code>{path: '/home', moduleId: 'home/homeView'}</code>. When you navigate to <code>/home</code> it will load the <code>home/homeView</code> module.</p>

    <h3>route.path</h3>

    <ul>
      <li>The simplest path is an exact match like <code>/home</code>.</li>
      <li>You can use wildcards to match a segment of a path. For example <code>/customer/*/name</code> will match <code>/customer/123/name</code>.</li>
      <li>You can use path variables to match a segment of a path. For example <code>/customer/:id/name</code> will match <code>/customer/123/name</code>. This will set <code>routeArguments.id = 123</code> in the <code>onRouteLoad(module, routeArguments)</code>.</li>
      <li>You can use a regular expression to do awesome pattern matching. For example <code>/^\/\w+\/\d+$/i</code> will match a pattern like <code>/word/number</code>.</li>
      <li>The catch-all path <code>'*'</code> will match everything. This is generally used to load a "Not Found" view.</li>
    </ul>

    <h3>route.moduleId</h3>

    <p>This is the AMD module ID. This is the ID you would use in a <code>require</code> or <code>define</code> statement like <code>require(['moduleId'], function(module) {})</code>.</p>

    <h3>route.active</h3>

    <p>Indicates if it's the active route. <code>true</code> if it's the active route, <code>false</code> or <code>undefined</code> otherwise. This is set by the router.</p>

    <h2>registerRoutes(routes)</h2>

    <p>Registers routes. You can call this multiple times to add additional routes.</p>

    <pre>router.registerRoutes({
  home: { path: '/home', moduleId: 'home/homeView' },
  notFound: { path: '*', moduleId: 'notFound/notFoundView' }
});</pre>

    <h2>init([options])</h2>

    <p>Adds <code>hashchange</code> and <code>popstate</code> event listeners to the window. These are consolidated into a <code>statechange</code> event that is used by the router. <code>init()</code> then sets up a default <code>statechange</code> event handler to call <code>loadCurrentRoute()</code>. Finally it fires a <code>statechange</code> to load the current route. You can set these options to prevent some of the default behavior.</p>

    <pre>router.init({
  // If this is false init() won't add a statechange event handler to call loadCurrentRoute()
  loadCurrentRouteOnStateChange: false,

  // If this is false init() won't fire a statechange event to load the current route
  fireInitialStateChange: false
});</pre>

    <h2>on('routeload', routeLoadedCallback)</h2>

    <p>Called when the route's AMD module finishes loading. Use this to render the view and attach it to the document. The module and route arguments will be passed as arguments. A simple <code>routeload</code> function like this will do everything you need.</p>

    <pre>router.on('routeload', function(module, routeArguments) {
  var body = document.querySelector('body');
  body.innerHTML = '';
  body.appendChild(new module(routeArguments).outerEl);
});</pre>

    <h2>routeArguments([route, [url]])</h2>

    <p>You can call <code>routeArguments()</code> without any parameters to get the route arguments for the current route.</p>

    <p>Route arguments contain path variables and query parameters. For example:</p>

    <pre>// This route and URL
var route = { path: '/customer/:id' };
var url = 'http://domain.com/customer/123?orderBy=descending&filter=true';

var routeArguments = router.routeArguments(route, url);</pre>

    <p>Will result in these <code>routeArguments</code></p>

    <pre>{
  id: 123,
  orderBy: 'descending',
  filter: true
}</pre>

    <p>The route arguments are parsed into their boolean, numeric, or decoded string formats.</p>

    <h2>urlPath(url)</h2>

    <p>Routes are first compared against the hash path (a hash starting in <code>#/</code> or <code>#!/</code>) and fall back to the regular path if no hash path exists. This allows one set of routes to work with both hashchange and HTML5 pushState. When a hashchange, popstate, or page load occures the router will find the first matching route and load that module.</p>

    <p>For example, these URLs all have this path <code>/example/path</code>.</p>

    <ul>
      <li><code>http://domain.com/example/path?queryParam=true</code></li>
      <li><code>http://domain.com/#/example/path?queryParam=true</code></li>
      <li><code>http://domain.com/#!/example/path?queryParam=true</code></li>
      <li><code>http://domain.com/other/path?queryParam2=false#/example/path?queryParam=true</code></li>
    </ul>

    <p>The 4th URL example ignores the normal path and query parameters since it has a hash path.</p>

    <h2>activeRoute</h2>

    <p>A reference to the active route. Example: <code>{path: '/home', moduleId: 'home/homeView'}</code></p>

    <h2>loadCurrentRoute()</h2>

    <p>Tells the router to load the module for the current route. This is called by the default <code>on('statechange', onStateChangeHandler)</code> any time a hashchange or popstate event is fired.</p>

    <h2>testRoute(route, [url])</h2>

    <p>Compares the route against the current URL. Returns <code>true</code> if it matches, <code>false</code> otherwise.</p>

    <h2>on('statechange', onStateChangeHandler)</h2>

    <p>Called when a hashchange or popstate event is fired. <code>init()</code> sets up a default <code>statechange</code> event handler that calls <code>loadCurrentRoute()</code>. You can pass an option to <code>init()</code> to override this if you need to write your own <code>statechange</code> handler to do custom logic before <code>loadCurrentRoute()</code> is called.</p>

    <h2>fire(eventName, [arg1, [arg2]])</h2>

    <p>Manually fire an event. The router fires <code>statechange</code> and <code>routeload</code> events. <code>statechange</code> is called when the browser fires a <code>hashchange</code> or <code>popstate</code>. <code>routeload</code> is called when the router finishes loading a module for a route. Use <code>routeload</code> to render your view.</p>

    <h2>off(eventName, eventHandler)</h2>

    <p>Remove an event handler. If you want remove an event handler you need to keep a reference to it so you can tell router.off() with the original event handler.</p>

  </div>
</div>
